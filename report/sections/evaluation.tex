\chapter{Evaluation}    
  \section{Limitations}
    There are of course several limitations in Echo. Firstly, we are unable to evaluate Behaviours at any time.
    Although this does not limit much of the development of real-time, interactive applications there is functionality
    lost. For instance it would be nice to be able to chart a Behaviour's value between certain bounds such as
    the trajectory of an object or a predetermined volume chart. This functionality can be provided with simple
    Time input functions but Behaviours could have provided a nice abstraction for these.
    
    The ability to transform Behaviours into different time frames is also lost due to the restriction on Behaviour
    evaluation. However, many of the use cases of this functionality can still be accomplished using the
    \emph{map} operation on Behaviours (such as slowing down or speeding up an animation Behaviour).
    
  \section{Efficiency}
    As stated at the beginning of this report one of the goals of this project was to create an efficient implementation
    of FRP. More specifically, one that doesn't require an unbounded level of memory use due to storing Event occurrences.
    It is seen in section 4 that this problem is avoided in Echo as Events only need to store their last
    occurrence. This not only means that Echo Events use a constant amount of memory but it also means there is
    no overhead associated with throwing out old occurrences (the last occurrence is simply replaced with the new 
    one whenever the Event occurs).
    
    As mentioned in section 4 Behaviour value caching is also used to prevent redundant reevaluation of Behaviours
    and this further leads to a more optimised implementation of FRP.
  
  \section{Demo Applications}
    So as to gain experience with using Echo and also for the purposes of evaluation, demonstration
    applications were developed. 
    
    The first of these was a small music player application. The application
    can load in a `.wav' audio file and then play it back to the user. Pause and volume changing functionality
    is also available and the user is presented with a simple animation of the current volume level. One of the
    first points to cover is that an abstraction had to be built to enable the audio playback. This was in the form
    of a `Song' component. For this component playback is controlled by a Behaviour[Boolean] of whether the audio
    should be playing or not and the volume is dictated by a Behaviour[Int] that represents the current percentage
    volume. Once the abstraction was in place programming the FRP logic for the application using the 
    graphics framework was very simple and, quite importantly, took very little time. It can be seen from
    the development of this application that abstractions over input and outputs would have to frequently be
    created to produce non-trivial FRP applications. However, any abstractions built would hopefully be
    reusable in nature due to FRPs high level approach to control. These findings also verify that it
    is important that Echo is as extendable as possible.
    
    Additional work was carried out on a small network anagram guessing game. This involved a server that provided
    an anagram and a client application that would present the anagram and allow the user to guess the original
    word. The user's answers would be reported to the server and the server would reply with whether
    the guess was correct or not. This application took advantage of the socket abstraction discussed in section 5
    and was actually very easy to develop with the Sender and Receiver types. Again, due to the functional and
    declarative nature of FRP the code for this application (both the server and the client) was very simple
    and intuitive to both create and read.
    
    Code excerpts from both demo applications can be seen in Appendix A and B. 