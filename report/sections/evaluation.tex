\chapter{Evaluation}
  
  \section{Verifying Correctness}
    Of course, there needs to be some way of verifying that the implementation is correct. By
    this it is meant that it follows both the semantic rules set forth by the original FRP specification
    and also the rules and constraints laid out in this report.
  
    This was achieved in echo using formal program testing. More specifically, Behaviour Driven
    testing was carried out throughout the development process using the Scala framework `Specs' \cite{EricTorreborre}
    to verify that implementations were correct. `Specs' and BDT involve series of tests for
    separate program `invariants' or `behaviours'. For example to test the Behaviour \emph{map} function
    in `Specs' we can do the following:

\begin{verbatim}
"provide a map function" >> {
  "returning a Behavior thats value is func(this.at(t))" in {
    val beh = new Behavior(time => 5)
    val func: Int => String = {
      int => int.toString
    }

    beh.map(func).eval() mustEqual "5"
  }
}
\end{verbatim}      

    These tests were generally written before implementing a feature and then run after every compilation. 
    This not only allowed the original implementation's correctness to be verified but
    allowed refactoring to be carried out very quickly and easily as testing would verify that any changes had not
    made the implementation incorrect.
    
  \section{Limitations}
    There are of course several limitations in `echo'. Firstly, we are unable to evaluate Behaviours at any time.
    Although this does not limit much of the development of real-time, interactive applications there is functionality
    lost. For instance it would be nice to be able to chart a Behaviour's value between certain bounds such as
    the trajectory of an object or a predetermined volume chart. This functionality can be provided with simple
    Time input functions but Behaviours could have provided a nice abstraction for these.
    
    The ability to transform Behaviours into different time frames is also lost due to the restriction on Behaviour
    evaluation. However, many of the use cases of this functionality can still be accomplished using the
    \emph{map} operation on Behaviours (such as slowing down or speeding up an animation Behaviour).
    
  \section{Efficiency}
    As stated earlier one of the goals of this project was to create an efficient implementation
    of FRP. It was seen that Events in `echo' are able to only use a small amount of memory by only
    needing to buffer `future' occurrences. As noted earlier this does mean however that it is still
    possible to create a memory leak with Events by instantiating an Event that occurs but is never 
    evaluated by a Behaviour. Of course, there is no practical use for an Event such as this as
    it would have no effect on anything whatsoever and would be effectively redundant. However, any documentation
    of `echo' should make note of this problem.
    
    As mentioned earlier Behaviour value caching is also used to prevent redundant reevaluation of Behaviours
    and this further leads to a more optimised implementation of FRP.
  
  \section{Impurity}
    It is important to note that `echo' does not attempt to deal with the problem that
    users are able to create impure functions to define Behaviours. For instance, a programmer could
    create a Behaviour that reads from some external source:

\begin{verbatim}
val imp = new Behaviour(time => Console.readLine)
\end{verbatim}    

    This Behaviour would actually block on evaluation until a user wrote a line to the program console. 
    Additionally, evaluating this Behaviour at a past time will return the `current' value. A
    Behaviour can also cause side effects:

\begin{verbatim}    
val imp = new Behaviour(time => println("Hello, world!"))
\end{verbatim}

    Unfortunately, without modifications to the Scala compiler there is little that can be done
    to verify that the functions used to define a Behaviour are pure (the actual function scope would
    have to be limited).
  
  \section{Demo Applications}
    So as to gain experience with using `echo' and also for the purposes of evaluation, demonstration
    applications were developed. 
    
    The first of these was a small music player application. The application
    can load in a `.wav' audio file and then play it back to the user. Pause and volume changing functionality
    is also available and the user is presented with a simple animation of the current volume level. One of the
    first points to cover is that an abstraction had to be built to enable the audio playback. This was in the form
    of a `Song' component. For this component playback is controlled by a Behaviour[Boolean] of whether the audio
    should be playing or not and the volume is dictated by a Behaviour[Int] that represents the current percentage
    volume. Once the abstraction was in place programming the FRP logic for the application using the 
    graphics framework was very simple and, quite importantly, took very little time. It can be seen from
    the development of this application that abstractions over input and outputs would have to frequently be
    created to produce non-trivial FRP applications. However, any abstractions built would hopefully be
    reusable in nature due to FRPs high level approach to control. These findings also verify that it
    is important that `echo' is as extendable as possible.
    
    Additional work was carried out on a small network anagram guessing game. This involved a server that provided
    an anagram and a client application that would present the anagram and allow the user to guess the original
    word. The user's answers would be reported to the server and the server would reply with whether
    the guess was correct or not. This application took advantage of the socket abstraction mentioned earlier
    and was actually very easy to develop with the Sender and Receiver types. Again, due to the functional and
    declarative nature of FRP the code for this application (both the server and the client) was very simple
    and intuitive to both create and read.
    
    Code excerpts from both demo applications can be seen in Appendix A and B. 