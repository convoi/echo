\chapter{Additional Work}
  Besides creating a framework for the core FRP concepts additional efforts
  were put towards creating FRP friendly abstractions for creating non-trivial user facing
  applications.
  
  \section{UI Framework}
    To enable users to build interactive user facing applications with Echo it would be useful to have a simple User 
    Interface framework in place. Of course Echo could interact with standard UI frameworks but the use of Behaviours 
    and Events would be very limited and clunky. The goal with the UI framework is to allow the programmer to define 
    attributes as Behaviours and have them kept up to date and to also interact with the user through FRP 
    Events. 

    So far, a small simple framework has been devised and implemented. Every component's attributes are Behaviours
    (such as width and height) and they will be kept up to date at all times. For instance:

\begin{verbatim}
val frame = Frame(new Behaviour(time => sin(time)), 200) 
\end{verbatim}

    This would create a Frame that at a time \emph{t} would have a width of \emph{sin(t)}.

    The implementation of this is based around re-evaluating and redrawing the graphics on a clock tick. Each 
    Frame has its own `clock' that updates all the components attached to the Frame at a standard interval (currently 
    20ms). The actual graphical code was built by simply abstracting over the Java Swing UI Framework \cite{Oracle}. This 
    allows the FRP 
    components to be built quickly as no actual lower level graphics code has to be implemented.

    The UI framework also allows the programmer to interact with the user via Events. Again this is best illustrated 
    with an example:

\begin{verbatim}
val button = Button("Click Me!")
val someString = "Hello!".until(button.click, "Goodbye!") 
\end{verbatim}

    Here it can be seen that the Button type has a \emph{click} event. This Event occurs every time the 
    Button is clicked by the user. This was made possible by abstracting over Swing's own event framework. Many other 
    FRP Events can be easily generated in this way in Swing.
  
  \section{IO Framework}
  \label{sec:io}
  As mentioned earlier FRP can ease programming functional I/O as FRP Events introduce a declarative way to represent 
  and interact with external sources. One obvious place to experiment with this is with socket programming. To create sockets 
  in FRP the two core Java socket abstractions Socket and ServerSocket were abstracted over to produce
  Sender and Receiver. 

  Sender represents an output socket and is constructed from an IP to connect to, a host port and an 
  EventSource[String]. Any occurrences in the Event will be sent to IP and port specified. The Receiver
  type only requires a port to be constructed but is itself an EventSource[String] of received messages. This allows 
  a programmer to send and receive messages between FRP applications running on different nodes (or in different processes).
  Here's an example program that sends a ``Ping" message every time a Button is pressed:

\begin{verbatim}
val button = Button("Ping")
val pinger = button.click.map((t, v) => "Ping")
val sender = Sender("localhost", 1997, pinger)
val receiver = Receiver(1997)
\end{verbatim}
  
  Additional functionality can be added by allowing Receiver to reply to received messages. This can be achieved by
  having an optional String =$>$ Behaviour[String] constructor argument. For example, a Receiver that replies
  ``Pong'' to each incoming message would be created like so:

\begin{verbatim}
val rec = Receiver(1997) {
  in => "Pong"
}
\end{verbatim}    

  One interesting problem encountered while developing the Socket abstraction was that of Exceptions. 
  Sockets can fail in many ways and in a JVM language this causes an Exception which will cause the program to exit. 
  The simplest way to deal with the problem would of course be to simply catch the Exceptions and ignore them (if they 
  occur) but this would mean any code written with FRP would be intolerant of external failure (disconnection to the 
  internet etc). An elegant solution was to abstract over Exceptions with Events}. To do this the socket types 
  have an \emph{errors} Event that occurs every time an Exception is thrown within their execution. For instance, in this 
  setup there is nothing for the program to connect to on port \emph{1997}:

\begin{verbatim}
val socket = Sender("localhost", 1997, Event(0, "Hello")) 
\end{verbatim}

  Here the Java socket code will fail as it will be refused a connection (causing an Exception). The errors Event
  will then occur with the Exception. This allows Exceptions to interact with the FRP paradigm and allows programmers to 
  build failure tolerant systems within an FRP setting. So this functionality could be used elsewhere it was generalised
  to create a Breakable trait. Classes that extend this trait are able to write code in a \emph{dangerous} function like so:

\begin{verbatim}
class Resource extends Breakable {
  dangerous {
    breakEverything()
  }
}

val broken = new Resource()
val errors = broken.errors
\end{verbatim}
  
  As described with Sender and Receiver any Exceptions that are thrown inside \emph{dangerous} will occur in the Breakable  
  \emph{errors} Event. 