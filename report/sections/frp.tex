\chapter{Functional Reactive Programming}
  \section{Origins}
    Functional Reactive Programming was originally proposed in the 1997 paper \emph{Functional
    Reactive Animation} by Conal Elliott and Paul Hudak \cite{Elliott1997}. In this paper Elliott and Hudak
    set forth a ``collection of data types and functions'' designed for creating interactive 
    animations in the form of a framework for Haskell named `Fran'. The paper eventually went on to
    win an award distinguishing it as the most influential paper of ICFP97 \cite{SIGPLAN}. 
    
    Since the original proposal of the paradigm there has been a great amount of research
    into implementation and modification of FRP. Hudak has mainly focused on experimenting with various
    implementation methods and a modification to the original semantics categorised as ``Arrow FRP''. Elliot's
    work has dealt with FRP on a more conceptual level. This work culminated in a further significant paper
    ``Push-Pull FRP'' \cite{Elliott2009}. This attempted to clarify much of the semantics in a way that allowed for efficient 
    and
    structured implementations. This report will not use any of the new concepts in ``Push-Pull'' for definitions
    of FRP types and operation but inspiration was taken from it for many aspects of the implementation of Echo.

  \section{Semantics}
    The ideas in in the the Fran paper and in following FRP work are based around two key data types: 
    Behaviours and Events. Here the semantics of the `classic' \footnote{Several
    flavours of FRP have emerged over the years and the term `classic' is often used to describe
    the FRP defined by, and directly descended from, Fran.} flavour of FRP explored in this report will be defined.
    
    Within this section we will explore a selection of the basic denotational semantics that Elliott
    and Hudak originally laid down and that we hope to implement in Scala. The semantic definitions will
    be presented using Scala syntax so as to provide continuity throughout the report.
  
    \subsection{Types}
      \subsubsection{Time}
        Although Behaviours and Events are the two key types in FRP we will often describe them
        in terms of Time so defining what is meant by this here is necessary. We often think of
        Time as a continuous value and so in in numerical terms this is best modelled by the
        Scala type Double. This is the definition we will use throughout this report:

\begin{verbatim}
type Time = Double
\end{verbatim}    

        However, there are some interesting properties of Time that we can utilise in FRP. For instance,
        conceptually there is no minimum Double value but with Time we can say that a given Time is `at least'
        some value. For instance, imagine we are recording the times at which a person claps: even though we
        may not know the time of the next clap we can always say that it is greater than `now'. This
        general assumption will be used internally within Echo. This idea is explored in great detail
        within two of Conal Elliott's papers \cite{Elliott1997}, \cite{Elliott2009} but will not feature
        heavily in this report for the sake of simplicity.
   
      \subsubsection{Behaviour}
        Behaviours are essentially values that change over time. Semantically we think of them as
        a function from Time to some type T:

\begin{verbatim}
Behaviour[T] : Time => T
\end{verbatim}
        
        We can access some Behaviour's value at some time \emph{t} with the \emph{at} function:

\begin{verbatim}
at[T](t  : Time, beh : Behaviour[T]) : T
\end{verbatim}
      
      \subsubsection{Event}
        Events can be thought of as an (infinite) stream of Time-value pairs:

\begin{verbatim}
Event[T] : Stream[(Time, T)]
\end{verbatim}
        
        As with Behaviours, we define a function to access an Event's data:
        
\begin{verbatim}
occs[T](ev : Event[T]) : Stream[(Time, T)]
\end{verbatim}
       
    \subsection{Operations}
      Elliot and Hudak additionally define a set of actions on Behaviours and Events.
      
      \subsubsection{Behaviours}
        We would like functions defined on static values to also be available to Behaviours. Hudak
        and Elliot define a series functions for accomplishing this:
        
\begin{verbatim}
liftn[T1,..,Tn U](a1 : T1,..,an : Tn => U, 
b1 : Behaviour[T1],..., bn : Behaviour[Tn]) : Behaviour[U]
at(lift(func, b1,...,bn), t) = func (at(b1, t),..., at(bn, t))
\end{verbatim}

      In the original paper it was noted that this was intended to also lift constants to Behaviours
      as in \emph{lift0(42)} for example. This functionality is not captured in the above function \footnote{It would
      be in Haskell}. We can just simply define an additional function for lifting constants however:

\begin{verbatim}
lift0[T](t : T) : Behaviour[T]
at(lift0(v), t) = v
\end{verbatim}
        
       It also may be useful to evaluate Behaviours in a modified time frame. For example, this allows
       slowing down or speeding up a Behaviour. We define this function like so:

\begin{verbatim}
timeTransform[T](beh : Behaviour[T], time : Behaviour[Time]) : Behaviour[T]
at(timeTransform(beh, timeBeh), t) = at(beh, at(timeBeh, t))
\end{verbatim}
        
      \subsubsection{Events}
        It is useful to be able to merge two Events into one. We can achieve this with the \emph{merge} function:

\begin{verbatim}
merge[T](ev1 : Event[T], ev2 : Event[T]) : Event[T]
def mergeStr[T](str1 : Stream[Time, T], str1 : Stream[Time, T]) = {
  if (str1.first.time <= str2.first.time) {
    new Stream(str1.first, mergeStr(str1.drop(1), str2))
  } else {
    new Stream(str2.first, mergeStr(str1, str2.drop(1)))
  }
}
merge(ev1, ev2).occs = mergeStr(occs(ev1), occs(ev2))
\end{verbatim}            

      It should be noted that if if an occurrence from \emph{ev1} and \emph{ev2} occur `simultaneously' (have the same time) then
      the occurrence from \emph{ev2} will be placed after in the merged stream. Another interesting point to explore
      here is that often we can't evaluate which Event occurred first. Imagine one Event has one occurrence in
      the future but the other has no occurrences: the second still might occur before the first, we just don't know it
      yet. In this situation we take advantage of the fact that the compared values are values in Time. Assuming
      Events cannot occur in the past we know that the second one will not occur until after the time `now' (the
      present time). Again, this concept is discussed at length by Conal Elliott \cite{Elliott2009}.
       
      Elliott and Hudak's paper also defined a series of transformer functions for Events. Here we define a
     `map' function for allowing the same functionality:

\begin{verbatim}
map[T, U](ev : Event[T], func : (Time, T) => U)  : Event[U]
occs(map(ev, func)) = occs(event).map(func)
\end{verbatim}     

      A function for flattening events is also defined:

\begin{verbatim}
delayOccs[T](t : Time, ev : Event[T])
occs(delayOccs(t, ev)) = occs(ev).map(o => (max(o._1, t), o._2))

join[T](ev : Event[Event[T]])  : Event[T]
occs(join(ev)) = occs(map(ev, e => delayOccs(e._1, e._2))).foldLeft(emptEv, (e, o) => merge(e, o))
\end{verbatim}        

      One caveat to this function is that any occurrences of Events that occur in \emph{ev} are delayed
      so their occurrence times are at least the time that their parent Event occurred. It could be argued that this should 
      not be the case but after consideration it was decided that it did not make sense for an inner Event's occurrences to 
      occur before the Event itself
      in most use cases. Consider this: if an inner Event is a user logging onto a chat room and its occurrences are 
      messages then how can a message occur before the user logs in?
        
      \subsubsection{Reactivity}
        One of the most powerful aspects of FRP is the ability to use Events to punctuate or `switch' Behaviours.
        The original Fran paper defined an \emph{untilB} function that was later renamed (more appropriately in the
        author's mind) to \emph{switcher} \cite{Elliott2009}:

\begin{verbatim}
switcher[T](ini : Behaviour[T], ev : Event[Behaviour[T]])
at(switcher(ini, ev), t) = at(occs(ev).filter(
                              (ti, v) => ti <= t).last), t)
\end{verbatim}

        Another useful interaction between Behaviours and Events is to be able to sample
        a Behaviour at the exact moment an Event occurs. This functionality was originally defined in the
        form of the \emph{snapshot} operation:

\begin{verbatim}
snapshot[T, U](beh : Behaviour[T], ev : Event[U]) : Event[(T, U)]
t = occs(ev)(x).time
occs(snapshot(beh, ev)(x)) = (t, at(beh, t))
\end{verbatim} 
  
  \section{Subtleties}
    FRP presents some subtle semantic problems and caveats that are not always immediately obvious.
    They will be explored here in an attempt to aid the reader's understanding.
     
    \subsection{Events as Monotonic Streams}
      As stated earlier, we think of Events as streams of Time-value pairs. What isn't immediately
      obvious is that we think of this stream as real-time data: each occurrence is a value that
      `occurs' at the time stated. This rationale also means that an Event is a `monotonic' stream in terms of
      occurrence times as the time of each occurrence will be greater than or equal to the last occurrence
      time.
      
      With the previous observations in mind it it can be seen that Events should not be treated as a
      standard data structure. Its noticeable that the earlier definition of the \emph{map} operation for
      Events does not provide a way to modify occurrence times. Here we will show why this is
      the case using a modified version of this function.
      
      First we define the new function:
      
\begin{verbatim}
dangerMap[T, U](ev : Event[T], func : (Time, T) => (Time, U))  : Event[U]
occs(map(ev, func)) = occs(event).map(func)
\end{verbatim}

      Now we can do the following:
      
\begin{verbatim}
val event2 = dangerMap(event1, (t, v) => (t - 1, v))
\end{verbatim}

      \emph{event2} makes no sense as when there is a new occurrence in \emph{event1} at time 
      \emph{t} a corresponding occurrence will be generated for \emph{event2} but at time 
      \emph{t - 1}. This means occurrences of this Event are happening in the past! We must
      be careful to avoid allowing situations like these to happen when implementing FRP.
      
    \subsection{Events are Infinite}  
      It is also important to highlight that an Event's stream is \emph{infinite}. This means
      that streams must be evaluated lazily: we can't merge two infinite streams when we actually
      call \emph{merge} as it would never finish! This also means that there are some things we
      can't express for an Event such as its `length' or its `last' element.
    
      
    \subsection{Interactive Behaviour}
      FRP runs into some of its most significant problems when it is combined with any
      sort of interactivity - unfortunately an area of programming it initially seems
      well equipped for. This is best explained with an example. For this example we will use an 
      Event[(Int, Int)] \emph{mousePos} that occurs every time the user's mouse moves with the new position:

\begin{verbatim}
val pos = switcher(lift0((0, 0)), map(mousePos, (t, pos) => lift0(t, pos)))
pos.at(2)
pos.at(5)
\end{verbatim}    

      Now, suppose the time when this code executes is \emph{4}. The first problem we can see here
      is that we are going to be evaluating \emph{pos} at a time greater than `now': we don't
      actually know if the mouse will move in the future. To deal with this we could delay the return
      result until we know the answer, raise the error or modify the original semantics. None of these solutions are
      particularly useful however.
      
      What about the past? Evaluating \emph{pos} at times before `now' certainly makes sense. However, if arbitrary
      access is allowed to the past in this way then we would have to store every occurrence
      of an Event. It may be the case that this is how Events must be implemented but it does
      mean that any FRP program would use an increasing amount of memory as its run time increased (
      not a desirable property of any piece of code). This will also result in very large Event data sets which
      may be impossible to traverse quickly for performing operations such as \emph{at}.
      
      These examples shows that implementing FRP without some restriction might either involve modifying the
      semantics or sacrificing efficiency.
  
  \section{Previous Work}
    As one might imagine, there has been previous work in implementing FRP in Scala. 

    \subsection{Reactive}
      Arguably the most significant of the FRP work in Scala is the library `reactive' created by `nafg \cite{Nafg}'. This    
      framework was designed to allow for the creation of functional reactive web applications however here we are concerned 
      with the basic FRP library `reactive-core'. Unfortunately while claiming to be an FRP library `Reactive'
      has a couple of problems.

      The framework is based around two types designed to represent Behaviours and Events respectively: Signals
      and EventStreams. EventStreams are very close to the original Event but Signal deviates quite significantly form 
      Behaviours. Signal is defined as follows:

      \begin{quote}
        In practical terms, a Signal has a current value, and an EventStream that, whenever the Signal's value changes,     
        fires the new value.
      \end{quote}  

      Although it is claimed that this results in Signals having a continuous value we can see
      that at any point in time it is really just a static value that changes at discrete point in
      time. We can see that this doesn't allow us to represent purely continuous values. For instance
      we could not represent the following basic Behaviour with a Signal:

\begin{verbatim}
new Behaviour(time => time)
\end{verbatim}

      It can be seen that a Signal[T] can however be represented in terms
      of the `switcher' function meaning that it does have some relevance to Behaviours:

\begin{verbatim}
def signal[T](v : T, ev : Event[T]) = {
  switcher(lift0(v), map(ev, (t, o) => lift0(o)))
}
\end{verbatim}  

      This functionality was additionally encapsulated within the `stepper' function in Conal Elliott's
      `Push-Pull' paper \cite{Elliott2009}:

\begin{verbatim}
stepper[T](v : T, ev : Event[T]) : Behaviour[T]
stepper(v, ev) = switcher(lift(v), map(ev, (t, o) => lift(o)))
\end{verbatim} 

      It can be seen here that although Signal provides a useful programming tool it is not an implementation
      of an FRP Behaviour and only allows for a subset of a Behaviour's functionality meaning that `Reactive'
      does not successfully implement FRPs semantics.

    \subsection{React}
      While not claiming to be an implementation of FRP the `React' framework proposed in the 
      paper `Deprecating the Observer Pattern' \cite{Maier2010} does utilise a notion of Events that, as cited in the paper,
      has its routes in FRP.

      The Event's in React are very similar to the Events in Fran \cite{Elliott1997}: they are conceptually infinite
      and have the \emph{merge} and \emph{map} operations defined on them. One slight difference is that React's
      Events expose an operation to allow them to `occur' with a public \emph{emit} function. This disrupts
      the abstraction of Events somewhat. For instance, if we have again have a \emph{mouseB} Event we could do the following:

\begin{verbatim}
val event = mouseB
event.emit(())
\end{verbatim}      

      Here we cause the mouse button Event to occur without the actual input occurring. It will be shown later how to     
      internalise this action effectively so as to maintain the abstraction. 

      Interestingly, React also contains a notion of Signals, just as Reactive does, 
      however it doesn't claim that these are an implementation of Behaviours (although the word `continuous' is
      used loosely in their description). 

  It can be seen from these examples that while many of the concepts from FRP are popular
  in the Scala community there has been little attempt to implement FRP within Scala while honouring
  the original denotational semantics.