\chapter{Previous Implementations}
  Since Fran was first announced there have been several further implementations of FRP's semantics. Here
  we will explore a selection of these, focusing on work carried out in both Haskell and Scala.
  
  \section{Haskell}
    Much of the FRP community could be described as a subset of the Haskell community due to FRP's
    origins and sensibilities. It's not surprising that there have been several major implementations
    of FRP in the language. Here we will explore on of the most prominent:
    
    \subsection{Reactive-Banana}
      `Reactive-Banana' is a Haskell FRP framework created by Heinrich Apfelmus \cite{Apfelmus}. Reactive-banana
      is directly based on the on the FRP defined in Functional Reactive Animation \cite{Elliott1997}. Apfelmus
      implements continuous Behaviours and Events in terms of these original semantics and the framework
      is quite popular. There has also been work into allowing Reactive-banana to integrate with event based
      frameworks (such as GUI frameworks) which is probably seen as an advantage for many potential users.
      
      Apfelmus' framework does drop some functionality from FRP in the form of the \emph{switcher} function as
      he argues that in some cases it requires storing the entire history of an Event (as discussed previously
      in section 2).

  \section{Scala}
    As one might imagine, there has been previous work in implementing FRP in Scala. 

    \subsection{Reactive}
      Arguably the most significant of the FRP work in Scala is the library `reactive' created by `nafg' \cite{Nafg}. This    
      framework was designed to allow for the creation of functional reactive web applications however here we are concerned 
      with the basic FRP library `reactive-core'. Unfortunately while claiming to be an FRP library `Reactive'
      has a couple of problems.

      The framework is based around two types designed to represent Behaviours and Events respectively: Signals
      and EventStreams. EventStreams are very close to the original Event semantics but Signal deviates quite significantly from 
      Behaviour's. Signal is defined as follows:

      \begin{quote}
        In practical terms, a Signal has a current value, and an EventStream that, whenever the Signal's value changes,     
        fires the new value.
      \end{quote}  

      Although it is claimed that this results in Signals having a continuous value we can see
      that it is really just a static value that changes at discrete point in
      time. We can see that this doesn't allow us to represent purely continuous values. For instance
      we could not represent the following basic Behaviour with a Signal:

\begin{verbatim}
new Behaviour(time => time)
\end{verbatim}

      It can be seen that a Signal[T] can however be represented in terms
      of the `switcher' function meaning that it does have some relevance to Behaviours:

\begin{verbatim}
def signal[T](v : T, ev : Event[T]) = {
  switcher(lift0(v), map(ev, (t, o) => lift0(o)))
}
\end{verbatim}  

      This functionality was additionally encapsulated within the `stepper' function in Conal Elliott's
      `Push-Pull' paper \cite{Elliott2009}:

\begin{verbatim}
stepper[T](v : T, ev : Event[T]) : Behaviour[T]
stepper(v, ev) = switcher(lift0(v), map(ev, (t, o) => lift0(o)))
\end{verbatim} 

      It can be seen here that although Signal provides a useful programming tool it is not an implementation
      of an FRP Behaviour and only allows for a subset of a Behaviour's functionality meaning that `Reactive'
      does not successfully implement FRPs semantics.

    \subsection{React}
      While not claiming to be an implementation of FRP the `React' framework proposed in the 
      paper `Deprecating the Observer Pattern' \cite{Maier2010} does utilise a notion of Events that, as cited in the paper,
      has its routes in FRP.

      The Event's in React are very similar to the Events in Fran \cite{Elliott1997}: they are conceptually infinite
      and have the \emph{merge} and \emph{map} operations defined on them. One slight difference is that React's
      Events expose an operation to allow them to `occur' with a public \emph{emit} function. This disrupts
      the abstraction of Events somewhat. For instance, if we have again have a \emph{mouseB} Event we could do the following:

\begin{verbatim}
val event = mouseB
event.emit(())
\end{verbatim}      

      Here we cause the mouse button Event to occur without the actual input occurring. It will be shown later how to     
      internalise this action effectively so as to maintain the abstraction. 

      Interestingly, React also contains a notion of Signals, just as Reactive does, 
      however it doesn't claim that these are an implementation of Behaviours (although the word `continuous' is
      used loosely in their description). 
      
\section{Comparison}
  We can compare these frameworks with respect to the presence of various key features. These are Behaviours, Events, 
  \emph{stepper} - discretely 
  changing value and \emph{switcher} - continuous value that switches to other continuous values at discrete points in time.
  
  \begin{center}
     \begin{tabular}{ | l | l | l | l | }
       \hline
        & Reactive-Banana & Reactive & React \\ \hline \hline
       Behaviours & Yes & No & No \\ \hline
       Events & Yes & Yes & Yes \\ \hline
       \emph{stepper} & Yes & Yes & Yes \\ \hline
       \emph{switcher} & No & No & No \\ \hline  
       \hline
     \end{tabular}
   \end{center}
   
   It can be seen that purely continuous Behaviours are often not implemented the \emph{stepper} version
   of them often is (it can be seen that this is very useful in Appendix A and B). In this report it will
   be shown that it is possible to implement all of these features in Scala without having to use unbounded levels
   of memory for Events.