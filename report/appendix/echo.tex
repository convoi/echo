\chapter{Echo Specification}

  This section will define the various types implemented in Echo's core package and their
  respective member and companion object functions. Operations will be defined 
  semantically in terms of the Fran semantics specified in section 2 of this report.

  \section*{Behaviour[T]}
    \subsection*{Concrete Members}
    \subsubsection*{def eval(): T}
      Evaluates and returns the current value of the
      Behaviour. If the current time is \emph{t} then the
      function can be expressed in the following manor:

\begin{verbatim}
beh.eval() = at(beh, t)
\end{verbatim}      
    
    \subsubsection*{def sample[U](ev : Event[U]) : Event[(U, T)]}
      Returns a Event[T] that occurs every time the given
      Event occurs with the value of the Behaviour at that time.
      The \emph{sample} function is an implementation of the \emph{snapshot} operation:
      
\begin{verbatim}
beh.sample(event) = snapshot(beh, event)
\end{verbatim}
    
    \subsubsection*{def until[A](ev: Event[A], beh: Behaviour[T]): Behaviour[T]}
      Returns a Behaviour that behaves as the callee until the
      Event occurs. It then switches to behaving as the passed
      Behaviour. The \emph{until} function can be determined in terms
      of \emph{switcher}:

\begin{verbatim}
beh1.until(ev, beh2) = switcher(beh1, map(ev, (t, v) => beh2))
\end{verbatim}      
      
    \subsubsection*{def toggle[A](ev: Event[A], beh: Behaviour[T]): Behaviour[T]}
      Returns a Behaviour that toggles between behaving as the callee
      and the passed Behaviour whenever the passed Event occurs. This function
      can be defined using the \emph{finite} function defined in chapter 2:

\begin{verbatim}      
def toggle(ev : Event[T], beh1 : Behaviour[T]) : Behaviour[T]
at(beh1.toggle(ev, beh2), t) = if (finite(ev, t).length % 2 == 0)
  { at(beh1, t) } else { at(beh2, t) }
\end{verbatim}

    \subsubsection*{def map[B](func: T =$>$ B): Behaviour[B]}
      Returns a Behaviour that transforms the callee's
      value with the passed function.
      This function can be expressed in terms of \emph{lift1}:

\begin{verbatim}
beh.map(func) = lift1(func, beh)
\end{verbatim}      
      
    \subsubsection*{def map2[U, V](beh: Behaviour[U])(func: (T, U) =$>$ V): Behaviour[V]}
      Returns a Behaviour that transforms the callee's
      and passed Behaviour's value with the passed function. This operation
      can be defined using \emph{lift2}:

\begin{verbatim}
beh1.map2(beh2)(func) = lift2(func, beh1, beh2)
\end{verbatim}      

    \subsubsection*{def map3[U, V, W](beh1: Behaviour[U], beh2: Behaviour[V])(func: (T, U, V) =$>$ W): Behaviour[W]}
      Returns a Behaviour that transforms the callee's
      and passed Behaviours' value with the passed function. It cab
      be expressed with \emph{lift3}:

\begin{verbatim}
beh1.map3(beh2, beh3)(func) = lift3(func, beh1, beh2, beh3)
\end{verbatim}    

    \subsection*{Companion Concrete Members}
    \subsubsection*{def apply[T](func : Time =$>$ T)}
      Standard constructor. Returns a Behaviour
      that can be expressed in the following way:

\begin{verbatim}
at(Behaviour(func), t) = func(t)
\end{verbatim}
      
  \section*{Event[T]}
    \subsection*{Concrete Members}
    \subsubsection*{def map[U](func: (Time, T) =$>$ U): Event[U]}
      Returns a new Event that's occurrence values
      are are the result of of transforming the
      callee's occurrences with the given function (occurrence
      times are unmodified). It can be defined in terms of 
      the Fran \emph{map} operation:

\begin{verbatim}
ev.map(func) = map(ev, merge)
\end{verbatim}      
    
    \subsubsection*{def filter(func: T =$>$ Boolean): Event[T]}
      Returns an Event that filters occurrences
      occurrences (via the value) of the callee
      with the given predicate. We can define it as such:

\begin{verbatim}
ev.filter(pred) = occs(ev).filter(pred)
\end{verbatim}
      
    \subsubsection*{def merge(event: Event[T]): Event[T]}
      Returns an Event that's occurrences
      are a merged version of the callee
      and the given Event (merged in time order
      with left precedence). The \emph{merge}
      function can be specified with the Fran \emph{merge}
      operation:

\begin{verbatim}
ev1.merge(ev2) = merge(ev1, ev2)
\end{verbatim}   

 \subsection*{Companion Concrete Members}
  \subsubsection*{def apply[T](value : T)}
    Returns an Event that occurs once at time 0:
  
\begin{verbatim}
occs(Event(value)).first = (0, value) 
\end{verbatim} 

  \subsubsection*{def apply[T]()}
    Returns an Event that never occurs:

\begin{verbatim}
occs(Event(value)).first = None
\end{verbatim} 

   \section*{Switcher[T] extends Behaviour[T]}
    \subsection*{Companion Concrete Members}
      \subsubsection*{def apply[T](beh : Behaviour[T], ev : Event[Behaviour[T]])}
        Can be defined in terms of the FRP \emph{switcher}
        operation:

\begin{verbatim}
Switcher(beh, ev) = switcher(beh, ev)
\end{verbatim}   

  \section*{Stepper[T] extends Behaviour[T]}
    \subsection*{Companion Concrete Members}
      \subsubsection*{def apply[T](ini : T, ev : Event[T])}
        Can be defined in terms of the FRP \emph{switcher} function:

\begin{verbatim}
Stepper(ini, ev) = switcher(lift0(in), map(ev, (t,v) => lift0(v))
\end{verbatim}