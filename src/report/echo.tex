\documentclass[12pt]{article}
\usepackage{minted}

\title{Implementing Functional Reactive Programming in Scala}
\author{Callum Stott - 0832894}

\begin{document}
  % Title page
  \maketitle
  \paragraph*{Abstract}
  Lorem ipsum
  
  % Acknowledgments
  \newpage
  \section*{Acknowledgments}
    Lorem ipsum
  
  % Contents
  \newpage
  \tableofcontents
  
  % Start of report
  \newpage
  
  \section{Introduction}
  Lorem ipsum
  \section{Functional Reactive Programming}
    \subsection{Origins}
      Functional Reactive Programming was originally proposed in the 1997 paper \emph{Functional
      Reactive Animation} by Conal Elliott and Paul Hudak. In this paper Elliott and Hudak
      set forth a ``collection of data types and function'' designed for creating interactive 
      animations. Further work has been carried out in both the semantics and implementation
      of FRP with Elliott and Hudak remaining pivotal figures in a growing community of researchers
      and developers.
      
    \subsection{Semantics}
      The ideas in FRA and in following FRP work are based around two key data types: 
      \emph{Behaviours} and \emph{Events}. This paper will deal with the \emph{classic} flavour of
      FRP (that descended directly from FRAN) and so will not deal with \emph{signals} and Arrow FRP
      concepts explored elsewhere. Here the semantics of the FRP explored in this report will be defined.
      
      Within this section we will explore a selection of the basic denotational semantics that Elliott
      and Hudak originally laid down and that we hope to implement in Scala. The semantic definitions will
      be presented using Scala syntax so as to provide continuity throughout the report.
    
      \subsubsection{Types}
        \paragraph{Behaviour}
          Behaviours are essentially values that change over time. Semantically we think of them as
          a function from Time to some type T:

\begin{verbatim}
Behaviour[T] : Time => T
\end{verbatim}
          
          We can access some Behaviour's value at some time `t' with the \emph{at} function:

\begin{verbatim}
at[T](t  : Time, beh : Behaviour[T]) : T
\end{verbatim}
        
        \paragraph{Event}
          Events can be thought of as an (infinite) stream of \emph{Time}-value pairs:

\begin{verbatim}
Event[T] : Stream[(Time, T)]
\end{verbatim}
          
          As with Behaviours, we define a function access an Event's data:
          
\begin{verbatim}
occs[T](ev : Event[T]) : Stream[(Time, T)]
\end{verbatim}
         
      \subsubsection{Operations}
        Elliot and Hudak additionally define a set of actions on Behaviours and Events. In the interest of
        conciseness not all of these operations will be shown here. They will explored later however.
        
        \paragraph{Behaviours}
          We would like functions defined on static values to also be available to \emph{Behaviours}. Hudak
          and Elliot define a series functions for accomplishing this:
          
\begin{verbatim}
liftn[T1,..,Tn U](a1 : T1,..,an : Tn => U, 
  b1 : Behaviour[T1],..., bn : Behaviour[Tn]) : Behaviour[U]
at(lift(func, b1,...,bn), t) = func (at(b1, t),..., at(bn, t))
\end{verbatim}

        In the original paper it was noted that this was intended to be used to also lift constants to Behaviours
        as in `lift0 42' for example. We can't express this as simply in Scala as was done in Haskell due to 
        the syntax of type signatures. We can define an additional function for this purpose explicitly however.

\begin{verbatim}
lift0[T](t : T) : Behaviour[T]
at(lift0(v), t) = v
\end{verbatim}
          
         It also may be useful to evaluate Behaviours in a modified time frame for slowing down or speeding
         up a Behaviour for example. We define this with the timeTransform function on a \emph{Behaviour[T]}:

\begin{verbatim}
timeTransform(beh : Behaviour[T], time : Behaviour[Time]) : Behaviour[T]
at(timeTransform(beh, timeBeh), t) = at(beh, at(timeBeh, t))
\end{verbatim}
          
        \paragraph{Events}
          It is useful to be able to merge two Events into one. We can do this with the merge function on an \emph{Event[T]}:
  
\begin{verbatim}
merge[T](ev1 : Event[T], ev2 : Event[T]) : Event[T]
def mergeStr[T](str1 : Stream[Time, T], str1 : Stream[Time, T]) = {
  if (str1.first.time <= str2.first.time) {
    new Stream(str1.first, mergeStr(str1.drop(1), str2))
  } else {
    new Stream(str2.first, mergeStr(str1, str2.drop(1)))
  }
}
merge(ev1, ev2).occs = mergeStr(occs(ev1), occs(ev2))
\end{verbatim}            

        It should be noted that if if an occurrence from ev1 and ev2 occur `simultaneously' (have the same time) then
        the occurrence from ev2 will be placed after in the merged stream.
         
         Elliott and Hudak's paper also defined a series of transformer functions for Events. We will define a
         `map' function for allowing the same functionality:
 
\begin{verbatim}
map[U](ev : Event[T], func : (Time, T) => U)  : Event[U]
occs(map(ev, func)) = occs(event).map(func)
\end{verbatim}         
          
        \paragraph{Reactivity}
          One of the most powerful aspects of FRP is the ability to use Events to punctuate or `switch' Behaviours.
          The original FRAN paper defined an `untilB' function that was later renamed (more appropriately in the
          author's mind) to `switcher':

\begin{verbatim}
switcher[T](ini : Behaviour[T], ev : Event[Behaviour[T]])
at(switcher(ini, ev), t) = at(occs(ev).filter(
                                (ti, v) => ti <= t).last), t)
\end{verbatim}

          Another useful interaction between Behaviours and Events is to be able to sample
          a Behaviour at the exact moment an Event occurs. This was originally defined in the
          form of the `snapshot' operation:

\begin{verbatim}
snapshot[T, U](beh : Behaviour[T], ev : Event[U]) : Event[(T, U)]
t = occs(ev)(x).time
occs(snapshot(beh, ev)(x)) = (t, at(beh, t))
\end{verbatim}          
          
          
  \section{Problems and Caveats}
    FRP presents some subtle semantic problems and caveats that are not always immediately obvious.
    They will be explored here in an attempt to aid the reader's understanding.
     
    \subsection{Events as Monotonic Streams}
    Lorem ipsum
    
    \subsection{Interactive Behaviours}
    Lorem ipsum
    
  \section{Implementation in Scala}
    As stated earlier this project dealt with implementing a framework for utilising FRP in the Scala programming
    language. This framework was dubbed `echo'. This section will explore the motivations and problems ahead of
    and also the choices made and results rendered during the implementation of \emph{echo}.
    
    \subsection{Scala}
      Scala is a multi-paradigm programming language that runs on the Java Virtual Machine. Scala programs are
      generally structured in an object oriented programming style like Java but it also incorporates many features of
      functional languages such as closures, high order functions, lazy initialisation and currying. These features aid
      implementation of FRP concepts as closures will allow for Behaviour definition and functions such as map on
      Behaviours and Events to be expressed in a more natural and succinct form. It is
      important to note that although Scala is thought of as `functional' its functions are not `pure'. This means
      that object functions and closures can cause side effects and be altered by external states.
      
      Scala also possesses a advanced, powerful and feature rich static type system. A few of these provide large
      advantages when implementing FRP. Firstly, Scala supports generic classes and it can be quite easily seen
      that both Behaviours and Events will rely on this feature for type safety. Scala additionally provides
      a rather unique type conversion functionality that allows types to be converted on the fly. This provides
      incredibly expressive and powerful ways to embed FRP into Scala and will be explored later.
      
    \subsection{Problems}
      % Impurity - we just have to deal with it (lots of Scala is like this)
    
    \subsection{Design Choices}
    Throughout its history FRP implementations have generally been carried out in Haskell. Due to the movement
    in setting and also in an effort to create a efficient implementation without sacrificing FRP's expressive power
    several design choices were made. 
    
      \subsubsection{Object Orientation}
        It would be possible to implement the original FRP operations as standalone functions. However, so
        as to conform to Scala Object Oriented style the operations will be attached to their respective
        classes. For instance, the `merge' operation will be used in the following way in echo:
        
\begin{verbatim}
val merged = event1.merge(event2)
\end{verbatim}

      This allows the FRP code to fit more naturally into Scala. We will also replace the `switcher' function
      with a type that extends Behaviour rather than a function:
      
\begin{verbatim}
val switch = new Switcher(iniBeh, behEvent)
\end{verbatim}

      \subsubsection{Implicit Lifting of Constants}
        As mentioned earlier, one of the most powerful features of Scala is it's ability to convert between
        types at run time. This is facilitated by the \emph{implicit} key word allowing a function to be defined
        that is automatically when a corresponding type mismatch occurs. This will be used in echo to allows 
        static values to be converted to Behaviours \emph{implicitly}.. This is implemented in the following way:  

\begin{verbatim}
implicit def liftConst[T](value : T) : Behaviour[T] = {
  new Behaviour(time => value)
}
\end{verbatim}              
        
        This would allow the following for instance:
 
\begin{verbatim}
val beh : Behaviour[Int] = 0
val switcher = new Switcher(false, eventBeh)
\end{verbatim}       

        It can immediately be seen that this allows the programmer to switch between static and more complex
        Behaviours in a very naturalistic manor.
      
      \subsubsection{Time Travel is Dangerous}
        % Relate back to interactive problems
        % Set out rules
        % Describe eval action on Behaviours
        % Removal of timeTransform
        
      \subsubsection{Time Freezing}
        % Describe instantaneous occurrence problem
        % Describe dynamic FRP problems and initial setup phase
      
      \subsubsection{Function Renaming}
        Although a small change it should also be noted that one of the functions originally defined
        has be renamed for the echo framework - `snapshot' was renamed to `sample'. This was done as
        it was felt it added more clarity to the function name was more appropriate given its use.
        
      \subsubsection{Function Additions}
        When considering different applications of the framework and also in an attempt to
        tackle the changes in expressiveness between Haskell and Scala some operations
        were added to the FRP in echo.
        
        Lifting of constants has already been discussed for echo but lifting of operators and
        functions presents a few problems. This is because function in Scala (as discussed earlier)
        are usually attached to classes. For instance, there is no `'+' operator in Scala: the numeric
        types have a plus function defined in their class declarations (how Scala actually performs additions
        is a topic for discussion elsewhere). This means that we cannot `lift' many of the operations we
        would want to. To solve this problem we can use a series of map functions. We can define these
        here for a \emph{Behaviour[T]}:

\begin{verbatim}
map[U](func : T => U) : Behaviour[U]
beh.map(func).at(t) = func(beh.at(t))

map2[U, V](beh1 : U)(func : (T, U) => V) : Behaviour[V]
beh.map2(beh1)(func).at(t) = func(beh.at(t), beh1.at(t))
\end{verbatim}        

        These functions allow Behaviours to be transformed and combined using functions
        normally applied to static values.
        
        In Hudak and Elliott's original paper an example is constructed to create a Behaviour
        that toggles back and forth between two given Behaviours whenever an Event occurs. This
        example took advantage of Haskell's lazy evaluation. While Scala is able to use lazy evaluation
        it requires extra work and at the time of writing requires some complex syntax. To tackle this
        a `toggle' function was added to echo to provide the functionality in the example out of the box.
        This is defined here for a \emph{Behaviour[T]}:
        
\begin{verbatim}
toggle(ev : Event[T], beh1 : Behaviour[T]) : Behaviour[T]
\end{verbatim}        
        
        It was felt that another common use of combining Behaviours and Events would be
        to switch from one Behaviour to another when an Event occurs (but not back again):

\begin{verbatim}
until(ev : Event[T], beh1 : Behaviour[T]) : Behaviour[T]
beh.until(ev, beh1).at(t) = new Switcher(beh, event.map((t,v) => beh1)).at(t)
\end{verbatim}        
        
        It is also useful to be able to to filter Events to produce a new one that only
        contains occurrences matching a predicate. This allows a Behaviour to only react
        to some occurrences from an Event. This is defined on an \emph{Event[T]}:
 
\begin{verbatim}
filter(predicate : T => Boolean) : Event[T]
event.filter(predFunc).occs = event.occs.filter(predFunc)
\end{verbatim}        
        
      \subsubsection{Extendability}
        It was decided form the initial stages of the project that \emph{echo} should provide
        a way for users to create their own FRP abstractions. Effort throughout the design and
        implementation was put into this feature.
        
        % EventSource as a way to add Event abstractions
        % Breakable to aid these abstractions
      
    \subsection{Implementation Choices}
      Lorem ipsum
      
      \subsubsection{Push vs Pull Events}
        Lorem ipsum
        
        % Use push for sampling and filtering
        % Use pull evaluation for map and merge for simplicity and to not hold up event occurring threads 
    
    \subsection{Correctness of Implementation}
      Of course, there needs to be some way of verifying that the implementation is correct. By
      this it is meant that it follows both the semantic rules set forth by the original FRP specification
      and also the rules and constraints laid out in this report.
      
      This achieved in echo using formal program testing. More specifically, Behaviour Driven
      testing was carried out throughout the development process using the Scala framework `Specs'
      to verify that implementations were correct. `Specs' and BDT involve series of tests for
      separate program `invariants' or `behaviours'. For example to test the Behaviour `map' function
      in `Specs' we can do the following:
 
\begin{verbatim}
"provide a map function" >> {
  "returning a Behavior thats value is func(this.at(t))" in {
    val beh = new Behavior(time => 5)
    val func: Int => String = {
      int => int.toString
    }

    beh.map(func).eval() mustEqual "5"
  }
}
\end{verbatim}      

    These tests were generally written before implementing a feature and then run after every compilation. 
    This not only allowed the original implementation's correctness to be verified but
    allowed refactoring to be carried out very quickly andeasily as testing would verify that any changes had not
    made the implementation incorrect.
      
  \section{Additional Work}
    Besides creating a framework for the core FRP concepts additional efforts
    were put towards creating FRP friendly abstractions for creating non-trivial user facing
    applications.
    
    \subsection{UI Framework}
      To enable users to build interactive user facing applications with echo it would be useful to have a simple User 
      Interface framework in place. Of course echo could interact with standard UI frameworks but the use of \emph{Behaviours} 
      and \emph{Events} would be very limited and clunky. The goal with the UI framework is to allow the programmer to define 
      attributes as \emph{Behaviours} and have them kept up to date and to also interact with the user through FRP 
      \emph{Events}. 

      So far, a small simple framework has been devised and implemented. Every component's attributes are \emph{Behaviours} 
      (such as width and height) and they will be kept up to date at all times. For instance:

\begin{verbatim}
val frame = Frame(new Behaviour(time => sin(time)), 200) 
\end{verbatim}

      This would create a Frame that at a time `t' would have a width of \emph{sin(t)}.

      The implementation of this is based around re-evaluating and redrawing the graphics on a clock tick. Each 
      \emph{Frame} has its own `clock' that updates all the components attached to the frame at a standard interval (currently 
      20ms). The actual graphical code was built by simply abstracting over the Java Swing UI Framework. This allows the FRP 
      components to be built quickly as no actual lower end graphics code has to be implemented.

      The UI framework also allows the programmer to interact with the user via \emph{Events}. Again this is best illustrated 
      with an example:

\begin{verbatim}
val button = Button("Click Me!") 
val hello = new Behaviour(time => "Hello")
val goodbye = new Behaviour(time => "Goodbye!")
val someString = hello.until(button.click, goodbye) 
\end{verbatim}

      Here it can be seen that the \emph{Button} type owns a `click' event. This \emph{Event} occurs every time the 
      \emph{Button} is clicked by the user. This was made possible by abstracting over Swing's own event framework. Many other 
      FRP \emph{Events} can be easily generated in this way in Swing.
    
    \subsection{IO Framework}
    Lorem ipsum
    
  \section{Uses of FRP}
  Lorem ipsum
  
    \subsection{Demo Applications}
    Lorem ipsum
    
    \subsection{Use in the Wild}
    Lorem ipsum
    
    \subsection{Possible Large Scale Use}
    Lorem ipsum
    
  \section{Limitations}
    Lorem ipsum
    
    \subsection{Need for Abstraction}
    Lorem ipsum
    
    \subsection{Learning Curve}
    Lorem ipsum
    
    \subsection{Where to Stop}
    Lorem ipsum
    
  \section{Conclusion}
  Lorem ipsum
  
\end{document}