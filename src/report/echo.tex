\documentclass[12pt]{article}
\usepackage{minted}

\title{Implementing Functional Reactive Programming in Scala}
\author{Callum Stott - 0832894}

\begin{document}
  % Title page
  \maketitle
  \paragraph*{Abstract}
  Lorem ipsum
  
  % Acknowledgments
  \newpage
  \section*{Acknowledgments}
    Lorem ipsum
  
  % Contents
  \newpage
  \tableofcontents
  
  % Start of report
  \newpage
  
  \section{Introduction}
  Lorem ipsum
  \section{Functional Reactive Programming}
    \subsection{Origins}
      Functional Reactive Programming was originally proposed in the 1997 paper \emph{Functional
      Reactive Animation} by Conal Elliott and Paul Hudak. In this paper Elliott and Hudak
      set forth a ``collection of data types and function'' designed for creating interactive 
      animations. Further work has been carried out in both the semantics and implementation
      of FRP with Elliott and Hudak remaining pivotal figures in a growing community of researchers
      and developers.
      
    \subsection{Semantics}
      The ideas in FRA and in following FRP work are based around two key data types: 
      \emph{Behaviours} and \emph{Events}. This paper will deal with the \emph{classic} flavour of
      FRP (that descended directly from FRAN) and so will not deal with \emph{signals} and Arrow FRP
      concepts explored elsewhere. Here the semantics of the FRP explored in this report will be defined.
      
      Within this section we will explore a selection of the basic denotational semantics that Elliott
      and Hudak originally laid down and that we hope to implement in Scala. The semantic definitions will
      be presented using Scala syntax so as to provide continuity throughout the report.
    
      \subsubsection{Types}
        \paragraph{Behaviour}
          Behaviours are essentially values that change over time. Semantically we think of them as
          a function from Time to some type T:

\begin{verbatim}
Behaviour[T] : Time => T
\end{verbatim}
          
          We can access some Behaviour's value at some time `t' with the \emph{at} function:

\begin{verbatim}
at[T](t  : Time, beh : Behaviour[T]) : T
\end{verbatim}
        
        \paragraph{Event}
          Events can be thought of as an (infinite) stream of \emph{Time}-value pairs:

\begin{verbatim}
Event[T] : Stream[(Time, T)]
\end{verbatim}
          
          As with Behaviours, we define a function access an Event's data:
          
\begin{verbatim}
occs[T](ev : Event[T]) : Stream[(Time, T)]
\end{verbatim}
         
      \subsubsection{Operations}
        Elliot and Hudak additionally define a set of actions on Behaviours and Events. In the interest of
        conciseness not all of these operations will be shown here. They will explored later however.
        
        \paragraph{Behaviours}
          We would like functions defined on static values to also be available to \emph{Behaviours}. Hudak
          and Elliot define a series functions for accomplishing this:
          
\begin{verbatim}
liftn[T1,..,Tn U](a1 : T1,..,an : Tn => U, 
  b1 : Behaviour[T1],..., bn : Behaviour[Tn]) : Behaviour[U]
at(lift(func, b1,...,bn), t) = func (at(b1, t),..., at(bn, t))
\end{verbatim}

        In the original paper it was noted that this was intended to be used to also lift constants to Behaviours
        as in `lift0 42' for example. We can't express this as simply in Scala as was done in Haskell due to 
        the syntax of type signatures. We can define an additional function for this purpose explicitly however.

\begin{verbatim}
lift0[T](t : T) : Behaviour[T]
at(lift0(v), t) = v
\end{verbatim}
          
         It also may be useful to evaluate Behaviours in a modified time frame for slowing down or speeding
         up a Behaviour for example. We define this with the timeTransform function on a \emph{Behaviour[T]}:

\begin{verbatim}
timeTransform(beh : Behaviour[T], time : Behaviour[Time]) : Behaviour[T]
at(timeTransform(beh, timeBeh), t) = at(beh, at(timeBeh, t))
\end{verbatim}
          
        \paragraph{Events}
          It is useful to be able to merge two Events into one. We can do this with the merge function on an \emph{Event[T]}:
  
\begin{verbatim}
merge[T](ev1 : Event[T], ev2 : Event[T]) : Event[T]
def mergeStr[T](str1 : Stream[Time, T], str1 : Stream[Time, T]) = {
  if (str1.first.time <= str2.first.time) {
    new Stream(str1.first, mergeStr(str1.drop(1), str2))
  } else {
    new Stream(str2.first, mergeStr(str1, str2.drop(1)))
  }
}
merge(ev1, ev2).occs = mergeStr(occs(ev1), occs(ev2))
\end{verbatim}            

        It should be noted that if if an occurrence from ev1 and ev2 occur `simultaneously' (have the same time) then
        the occurrence from ev2 will be placed after in the merged stream.
         
         Elliott and Hudak's paper also defined a series of transformer functions for Events. We will define a
         `map' function for allowing the same functionality:
 
\begin{verbatim}
map[U](ev : Event[T], func : (Time, T) => U)  : Event[U]
occs(map(ev, func)) = occs(event).map(func)
\end{verbatim}         
          
        \paragraph{Reactivity}
          One of the most powerful aspects of FRP is the ability to use Events to punctuate or `switch' Behaviours.
          The original FRAN paper defined an `untilB' function that was later renamed (more appropriately in the
          author's mind) to `switcher':

\begin{verbatim}
switcher[T](ini : Behaviour[T], ev : Event[Behaviour[T]])
at(switcher(ini, ev), t) = at(occs(ev).filter(
                                (ti, v) => ti <= t).last), t)
\end{verbatim}
          
          
  \section{Problems and Caveats}
    FRP presents some subtle semantic problems and caveats that are not always immediately obvious.
    They will be explored here in an attempt to aid the reader's understanding.
     
    \subsection{Events as Monotonic Streams}
    Lorem ipsum
    
    \subsection{Interactive Behaviours}
    Lorem ipsum
    
  \section{Implementation in Scala}
    As stated earlier this project dealt with implementing a framework for utilising FRP in the Scala programming
    language. This framework was dubbed `echo'. This section will explore the motivations and problems ahead of
    and also the choices made and results rendered during the implementation of \emph{echo}.
    
    \subsection{Scala}
      Scala is a multi-paradigm programming language that runs on the Java Virtual Machine. Scala programs are
      generally structured in an object oriented programming style like Java but it also incorporates many features of
      functional languages such as closures, high order functions, lazy initialisation and currying. These features aid
      implementation of FRP concepts as closures will allow for Behaviour definition and functions such as map on
      Behaviours and Events to be expressed in a more natural and succinct form. It is
      important to note that although Scala is thought of as `functional' its functions are not `pure'. This means
      that object functions and closures can cause side effects and be altered by external states.
      
      Scala also possesses a advanced, powerful and feature rich static type system. A few of these provide large
      advantages when implementing FRP. Firstly, Scala supports generic classes and it can be quite easily seen
      that both Behaviours and Events will rely on this feature for type safety. Scala additionally provides
      a rather unique type conversion functionality that allows types to be converted on the fly. This provides
      incredibly expressive and powerful ways to embed FRP into Scala and will be explored later.
      
    \subsection{Problems}
      % Impurity - we just have to deal with it (lots of Scala is like this)
    
    \subsection{Design Choices}
    Throughout its history FRP implementations have generally been carried out in Haskell. Due to the movement
    in setting and also in an effort to create a efficient implementation without sacrificing FRP's expressive power
    several design choices were made. 
    
      \subsubsection{Object Orientation}
        It would be possible to implement the original FRP operations as standalone functions. However, so
        as to conform to Scala Object Oriented style the operations will be attached to their respective
        classes. For instance, the `merge' operation will be used in the following way in echo:
        
\begin{verbatim}
val merged = event1.merge(event2)
\end{verbatim}

      This allows the FRP code to fit more naturally into Scala. We will also replace the `switcher' function
      with a type that extends Behaviour rather than a function:
      
\begin{verbatim}
val switch = new Switcher(iniBeh, behEvent)
\end{verbatim}

      \subsubsection{Implicit Lifting of Constants}
        As mentioned earlier, one of the most powerful features of Scala is it's ability to convert between
        types at run time. This is facilitated by the \emph{implicit} key word allowing a function to be defined
        that is automatically when a corresponding type mismatch occurs. This will be used in echo to allows 
        static values to be converted to Behaviours \emph{implicitly}.. This is implemented in the following way:  

\begin{verbatim}
implicit def liftConst[T](value : T) : Behaviour[T] = {
  new Behaviour(time => value)
}
\end{verbatim}              
        
        This would allow the following for instance:
 
\begin{verbatim}
val beh : Behaviour[Int] = 0
val switcher = new Switcher(false, eventBeh)
\end{verbatim}       

        It can immediately be seen that this allows the programmer to switch between static and more complex
        Behaviours in a very naturalistic manor.
      
      \subsubsection{Time Travel is Dangerous}
      Lorem ipsum
      
      \subsubsection{Function Renaming}
      Lorem ipsum
      
      \subsubsection{Flat Time}
      Lorem ipsum
      
      \subsubsection{Extendability}
      It was decided form the initial stages of the project that \emph{echo} should provide
      a way for users to create their own FRP abstractions. Effort throughout the design and
      implementation was put into this feature.
      
      \subsubsection{Initial Setup Phase}
      Lorem ipsum
      
    \subsection{Implementation Choices}
      Lorem ipsum
      
      \subsubsection{Push vs Pull}
      Lorem ipsum
    
    \subsection{Correctness of Implementation}
      Lorem ipsum 
      
  \section{Additional Work}
    Besides creating a framework for the core FRP concepts additional efforts
    were put towards creating FRP friendly abstractions for creating non-trivial user facing
    applications.
    
    \subsection{UI Framework}
    Lorem ipsum
    
    \subsection{IO Framework}
    Lorem ipsum
    
  \section{Uses of FRP}
  Lorem ipsum
  
    \subsection{Demo Applications}
    Lorem ipsum
    
    \subsection{Use in the Wild}
    Lorem ipsum
    
    \subsection{Possible Large Scale Use}
    Lorem ipsum
    
  \section{Limitations}
    Lorem ipsum
    
    \subsection{Need for Abstraction}
    Lorem ipsum
    
    \subsection{Learning Curve}
    Lorem ipsum
    
    \subsection{Where to Stop}
    Lorem ipsum
    
  \section{Conclusion}
  Lorem ipsum
  
\end{document}