\documentclass[12pt]{article}
\usepackage{minted}

\title{Implementing Functional Reactive Programming in Scala}
\author{Callum Stott - 0832894}

\begin{document}
  % Title page
  \maketitle
  \paragraph*{Abstract}
  
  % Acknowledgments
  \newpage
  \section*{Acknowledgments}
    
  
  % Contents
  \newpage
  \tableofcontents
  
  % Start of report
  \newpage
  
  \section{Introduction}
  
  \section{Functional Reactive Programming}
    \subsection{Origins}
      Functional Reactive Programming was originally proposed in the 1997 paper \emph{Functional
      Reactive Animation} by Conal Elliott and Paul Hudak. In this paper Elliott and Hudak
      set forth a ``collection of data types and function'' designed for creating interactive 
      animations. Further work has been carried out in both the semantics and implementation
      of FRP with Elliott and Hudak remaining pivotal figures in a growing community of researchers
      and developers.
      
    \subsection{Semantics}
      The ideas in FRA and in following FRP work are based around two key data types: 
      \emph{Behaviours} and \emph{Events}. This paper will deal with the \emph{classic} flavour of
      FRP (that descended directly from FRAN) and so will not deal with \emph{signals} and Arrow FRP
      concepts explored elsewhere. Here the semantics of the FRP explored in this report will be defined.
      
      Within this section we will explore a selection of the basic denotational semantics that Elliott
      and Hudak originally laid down and that we hope to implement in Scala. The semantic definitions will
      be presented using Scala syntax so as to provide continuity throughout the report.
    
      \subsubsection{Types}
        \paragraph{Behaviour}
          Behaviours are essentially values that change over time. Semantically we think of them as
          a function from Time to some type T:

\begin{verbatim}
Behaviour[T] : Time => T
\end{verbatim}
          
          We can access some Behaviour's value at some time `t' with the \emph{at} function:

\begin{verbatim}
at[T](t  : Time, beh : Behaviour[T]) : T
\end{verbatim}
        
        \paragraph{Event}
          Events can be thought of as an (infinite) stream of \emph{Time}-value pairs:

\begin{verbatim}
Event[T] : Stream[(Time, T)]
\end{verbatim}
          
          As with Behaviours, we define a function access an Event's data:
          
\begin{verbatim}
occs[T](ev : Event[T]) : Stream[(Time, T)]
\end{verbatim}
         
      \subsubsection{Operations}
        Elliot and Hudak additionally define a set of actions on Behaviours and Events. In the interest of
        conciseness not all of these operations will be shown here. They will explored later however.
        
        \paragraph{Behaviours}
          We would like functions defined on static values to also be available to \emph{Behaviours}. Hudak
          and Elliot define a series functions for accomplishing this:
          
\begin{verbatim}
liftn[T1,..,Tn U](a1 : T1,..,an : Tn => U, 
  b1 : Behaviour[T1],..., bn : Behaviour[Tn]) : Behaviour[U]
at(lift(func, b1,...,bn), t) = func (at(b1, t),..., at(bn, t))
\end{verbatim}

        In the original paper it was noted that this was intended to be used to also lift constants to Behaviours
        as in `lift0 42' for example. We can't express this as simply in Scala as was done in Haskell due to 
        the syntax of type signatures. We can define an additional function for this purpose explicitly however.

\begin{verbatim}
lift0[T](t : T) : Behaviour[T]
at(lift0(v), t) = v
\end{verbatim}
          
         It also may be useful to evaluate Behaviours in a modified time frame for slowing down or speeding
         up a Behaviour for example. We define this with the timeTransform function on a \emph{Behaviour[T]}:

\begin{verbatim}
timeTransform(beh : Behaviour[T], time : Behaviour[Time]) : Behaviour[T]
at(timeTransform(beh, timeBeh), t) = at(beh, at(timeBeh, t))
\end{verbatim}
          
        \paragraph{Events}
          It is useful to be able to merge two Events into one. We can do this with the merge function on an \emph{Event[T]}:
  
\begin{verbatim}
merge[T](ev1 : Event[T], ev2 : Event[T]) : Event[T]
def mergeStr[T](str1 : Stream[Time, T], str1 : Stream[Time, T]) = {
  if (str1.first.time <= str2.first.time) {
    new Stream(str1.first, mergeStr(str1.drop(1), str2))
  } else {
    new Stream(str2.first, mergeStr(str1, str2.drop(1)))
  }
}
merge(ev1, ev2).occs = mergeStr(occs(ev1), occs(ev2))
\end{verbatim}            

        It should be noted that if if an occurrence from ev1 and ev2 occur `simultaneously' (have the same time) then
        the occurrence from ev2 will be placed after in the merged stream.
         
         Elliott and Hudak's paper also defined a series of transformer functions for Events. We will define a
         `map' function for allowing the same functionality:
 
\begin{verbatim}
map[U](ev : Event[T], func : (Time, T) => U)  : Event[U]
occs(map(ev, func)) = occs(event).map(func)
\end{verbatim}         
          
        \paragraph{Reactivity}
          One of the most powerful aspects of FRP is the ability to use Events to punctuate or `switch' Behaviours.
          The original FRAN paper defined an `untilB' function that was later renamed (more appropriately in the
          author's mind) to `switcher':

\begin{verbatim}
switcher[T](ini : Behaviour[T], ev : Event[Behaviour[T]])
at(switcher(ini, ev), t) = at(occs(ev).filter(
                                (ti, v) => ti <= t).last), t)
\end{verbatim}

          Another useful interaction between Behaviours and Events is to be able to sample
          a Behaviour at the exact moment an Event occurs. This was originally defined in the
          form of the `snapshot' operation:

\begin{verbatim}
snapshot[T, U](beh : Behaviour[T], ev : Event[U]) : Event[(T, U)]
t = occs(ev)(x).time
occs(snapshot(beh, ev)(x)) = (t, at(beh, t))
\end{verbatim}          
          
          
  \section{Problems and Caveats}
    FRP presents some subtle semantic problems and caveats that are not always immediately obvious.
    They will be explored here in an attempt to aid the reader's understanding.
     
    \subsection{Events as Monotonic Streams}
      As stated earlier, we think of Events as streams of Time-value pairs. What isn't immediately
      obvious is that we think of this stream as real-time data: each occurrence is a value that
      `occurs' at the time stated. This also means that an Event is a `monotonic' stream in terms of
      occurrence times as the time of each occurrence will be greater than or equal to the last occurrence
      time.
      
      With these observations in mind it it can be seen that Events should not be treated as a
      standard data structure. Its noticeable that the earlier definition of the `map' operation for
      Events does not provide a way to modify occurrence times. Here we will show why this is
      the case using a modified version of this function.
      
      First we define the new function:
      
\begin{verbatim}
dangerMap[U](ev : Event[T], func : (Time, T) => (Time, U))  : Event[U]
occs(map(ev, func)) = occs(event).map(func)
\end{verbatim}

      Now we can do the following:
      
\begin{verbatim}
val event2 = dangerMap(event1, (t, v) => (t - 1, v))
\end{verbatim}

      This new Event makes no sense as when there is a new occurrence in \emph{event1} at time 
      \emph{t} a corresponding occurrence will be generated for \emph{event2} but at time 
      \emph{t - 1}. This means occurrences of this Event are happening in the past! We must
      be careful to avoid allowing situations like these to happen when implementing FRP.
      
    \subsection{Events are Infinite}  
      It is also important to highlight that an Event's stream in \emph{infinite}. This means
      that streams must be evaluated lazily: we can't merge two infinite streams when we actually
      call `merge' as it would never finish! This also means that there are some things we
      can't express for an Event such as its `length' or its `last' element.
    
      
    \subsection{Interactive Behaviours}
      % Interactivity causes problems
      % Switcher based on mousePos Event example
      % Semantic problem with reading future
      % Unbound memory with reading the past
    
  \section{Implementation in Scala}
    As stated earlier this project dealt with implementing a framework for utilising FRP in the Scala programming
    language. This framework was dubbed `echo'. This section will explore the motivations and problems ahead of
    and also the choices made and results rendered during the implementation of \emph{echo}.
    
    \subsection{Scala}
      Scala is a multi-paradigm programming language developed to run on the Java Virtual Machine. Scala programs are
      generally structured in an object oriented programming style like Java but it also incorporates many features of
      functional languages such as closures, high order functions, lazy initialisation and currying. These features aid
      implementation of FRP concepts as closures will allow for Behaviour definition and functions such as map on
      Behaviours and Events to be expressed in a more natural and succinct form. It is
      important to note that although Scala is thought of as `functional' its functions are not `pure'. This means
      that object functions and closures can cause side effects and be altered by external states.
      
      Scala also possesses a advanced, powerful and feature rich static type system. A few of these provide large
      advantages when implementing FRP. Firstly, Scala supports generic classes and it can be quite easily seen
      that both Behaviours and Events will rely on this feature for type safety. Scala additionally provides
      a rather unique type conversion functionality that allows types to be converted on the fly. This provides
      incredibly expressive and powerful ways to embed FRP into Scala and will be explored later.
      
    \subsection{Problems}
      % Impurity - we just have to deal with it (lots of Scala is like this)
      
    \subsection{Previous Work}
      
    \subsection{A Brief Introduction to Echo}
    
    \subsection{Design Choices}
    Throughout its history FRP implementations have generally been carried out in Haskell. Due to the movement
    in setting and also in an effort to create a efficient implementation without sacrificing FRP's expressive power
    several design choices were made. 
    
      \subsubsection{Object Orientation}
        It would be possible to implement the original FRP operations as standalone functions. However, so
        as to conform to Scala Object Oriented style the operations will be attached to their respective
        classes. For instance, the `merge' operation will be used in the following way in echo:
        
\begin{verbatim}
val merged = event1.merge(event2)
\end{verbatim}

      This allows the FRP code to fit more naturally into Scala. We will also replace the `switcher' function
      with a type that extends Behaviour rather than a function:
      
\begin{verbatim}
val switch = new Switcher(iniBeh, behEvent)
\end{verbatim}

      \subsubsection{Implicit Lifting of Constants}
        As mentioned earlier, one of the most powerful features of Scala is it's ability to convert between
        types at run time. This is facilitated by the \emph{implicit} key word allowing a function to be defined
        that is automatically when a corresponding type mismatch occurs. This will be used in echo to allows 
        static values to be converted to Behaviours \emph{implicitly}.. This is implemented in the following way:  

\begin{verbatim}
implicit def liftConst[T](value : T) : Behaviour[T] = {
  new Behaviour(time => value)
}
\end{verbatim}              
        
        This would allow the following for instance:
 
\begin{verbatim}
val beh : Behaviour[Int] = 0
val switcher = new Switcher(false, eventBeh)
\end{verbatim}       

        It can immediately be seen that this allows the programmer to switch between static and more complex
        Behaviours in a very naturalistic manor.
      
      \subsubsection{Time Travel is Dangerous}
        Relating back to the earlier discussion of interactive Behaviours it can be seen
        that there are problems when plugging FRP into the real world: the future is uncertain and
        arbitrary access to the past requires an unbounded level of memory. After much deliberation
        over different compromises it was decided that echo would follow a set of rules:
        
        \begin{itemize}
          \item If a Behaviour was last evaluated at time \emph{u} then it can only be evaluated at
          a time \emph{t} if t >= u.
          \item An Event holds the last time it occurred and the time up to which it hasn't occurred
          again (the time it is `valid' until).
          \item An Event is valid up until the time equivalent to `now' (the actual current time).
          \item If a Behaviour depends on some Event then we can only evaluate the Behaviour up to
          the time the Event is valid.
        \end{itemize}
        
        With this set of rules in place, it becomes clear that we will only ever use a fixed amount of memory
        for an Event and that a Behaviour can not be evaluated in the past or the future. Will
        introduce a new operation on a \emph{Behaviour[T]} for this:

\begin{verbatim}
eval() : T
beh.eval() = beh.at(now())
\end{verbatim}       

        We will also remove the `at' function on Behaviours from the public API (it will still be
        use within the framework). 
        
        Of course, the rules can still be broken if we introduce multi-threading and this is best illustrated
        with an example:
        
\begin{verbatim}
val beh = new Behaviour(time => 5)

class Runner extends Runnable() {
  def run() {
    beh.eval()
  }
}

new Thread(new Runner).start()
new Thread(new Runner).start()
\end{verbatim}       

        Here we have two threads continuously evaluating one Behaviour. This means that one thread
        might call \emph{eval()} and then be scheduled out allowing the other to proceed to evaluate
        at a later time. If the original is then scheduled back in it is possible it will
        be evaluating the Behaviour at a time less than the time second evaluated it at. This suggests
        that we desire the \emph{eval} operation to be `atomic'. This can be achieved easily for standalone
        Behaviours using standard locking tools in Scala.
        
        We run into further problems however if the Behaviour is more complex. Suppose, in the above example,
        the Behaviour was defined as follows:

\begin{verbatim}
val beh = beh1.until(ev, beh2)
\end{verbatim}        

        Here, \emph{beh} `depends' on \emph{beh1} and \emph{beh2}: whenever we evaluate \emph{beh}
        we also need to evaluate \emph{beh1} or \emph{beh2}. This shows that Behaviours can't just
        be locked on a standalone basis but must share a lock with all their dependencies and other Behaviours
        that share those dependencies. By this it is meant that a group of dependent Behaviours can
        only be read by one thread at a time.
        
      \subsubsection{Time Freezing}
        % Describe instantaneous occurrence problem
        % Describe dynamic FRP problems and initial setup phase
      
      \subsubsection{Function Renaming}
        Although a small change it should also be noted that one of the functions originally defined
        has be renamed for the echo framework - `snapshot' was renamed to `sample'. This was done as
        it was felt it added more clarity to the function name was more appropriate given its use.
        
      \subsubsection{Function Additions}
        When considering different applications of the framework and also in an attempt to
        tackle the changes in expressiveness between Haskell and Scala some operations
        were added to the FRP in echo.
        
        Lifting of constants has already been discussed for echo but lifting of operators and
        functions presents a few problems. This is because function in Scala (as discussed earlier)
        are usually attached to classes. For instance, there is no `'+' operator in Scala: the numeric
        types have a plus function defined in their class declarations (how Scala actually performs additions
        is a topic for discussion elsewhere). This means that we cannot `lift' many of the operations we
        would want to. To solve this problem we can use a series of map functions. We can define these
        here for a \emph{Behaviour[T]}:

\begin{verbatim}
map[U](func : T => U) : Behaviour[U]
beh.map(func).at(t) = func(beh.at(t))

map2[U, V](beh1 : U)(func : (T, U) => V) : Behaviour[V]
beh.map2(beh1)(func).at(t) = func(beh.at(t), beh1.at(t))
\end{verbatim}        

        These functions allow Behaviours to be transformed and combined using functions
        normally applied to static values.
        
        In Hudak and Elliott's original paper an example is constructed to create a Behaviour
        that toggles back and forth between two given Behaviours whenever an Event occurs. This
        example took advantage of Haskell's lazy evaluation. While Scala is able to use lazy evaluation
        it requires extra work and at the time of writing requires some complex syntax. To tackle this
        a `toggle' function was added to echo to provide the functionality in the example out of the box.
        This is defined here for a \emph{Behaviour[T]}:
        
\begin{verbatim}
toggle(ev : Event[T], beh1 : Behaviour[T]) : Behaviour[T]
\end{verbatim}        
        
        It was felt that another common use of combining Behaviours and Events would be
        to switch from one Behaviour to another when an Event occurs (but not back again):

\begin{verbatim}
until(ev : Event[T], beh1 : Behaviour[T]) : Behaviour[T]
beh.until(ev, beh1).at(t) = new Switcher(beh, event.map((t,v) => beh1)).at(t)
\end{verbatim}        
        
        It is also useful to be able to to filter Events to produce a new one that only
        contains occurrences matching a predicate. This allows a Behaviour to only react
        to some occurrences from an Event. This is defined on an \emph{Event[T]}:
 
\begin{verbatim}
filter(predicate : T => Boolean) : Event[T]
event.filter(predFunc).occs = event.occs.filter(predFunc)
\end{verbatim}        
        
      \subsubsection{Extendability}
        It was decided form the initial stages of the project that \emph{echo} should provide
        a way for users to create their own FRP abstractions. Effort throughout the design and
        implementation was put into this feature.
        
        % EventSource as a way to add Event abstractions
        % Breakable to aid these abstractions
      
    \subsection{Implementation Choices}
      
      \subsubsection{Push vs Pull Events}
        % Use push for sampling and filtering
        % Use pull evaluation for map and merge for simplicity and to not hold up event occurring threads 
    
    \subsection{Correctness of Implementation}
      Of course, there needs to be some way of verifying that the implementation is correct. By
      this it is meant that it follows both the semantic rules set forth by the original FRP specification
      and also the rules and constraints laid out in this report.
      
      This achieved in echo using formal program testing. More specifically, Behaviour Driven
      testing was carried out throughout the development process using the Scala framework `Specs'
      to verify that implementations were correct. `Specs' and BDT involve series of tests for
      separate program `invariants' or `behaviours'. For example to test the Behaviour `map' function
      in `Specs' we can do the following:
 
\begin{verbatim}
"provide a map function" >> {
  "returning a Behavior thats value is func(this.at(t))" in {
    val beh = new Behavior(time => 5)
    val func: Int => String = {
      int => int.toString
    }

    beh.map(func).eval() mustEqual "5"
  }
}
\end{verbatim}      

    These tests were generally written before implementing a feature and then run after every compilation. 
    This not only allowed the original implementation's correctness to be verified but
    allowed refactoring to be carried out very quickly andeasily as testing would verify that any changes had not
    made the implementation incorrect.
      
  \section{Additional Work}
    Besides creating a framework for the core FRP concepts additional efforts
    were put towards creating FRP friendly abstractions for creating non-trivial user facing
    applications.
    
    \subsection{UI Framework}
      To enable users to build interactive user facing applications with echo it would be useful to have a simple User 
      Interface framework in place. Of course echo could interact with standard UI frameworks but the use of \emph{Behaviours} 
      and \emph{Events} would be very limited and clunky. The goal with the UI framework is to allow the programmer to define 
      attributes as \emph{Behaviours} and have them kept up to date and to also interact with the user through FRP 
      \emph{Events}. 

      So far, a small simple framework has been devised and implemented. Every component's attributes are \emph{Behaviours} 
      (such as width and height) and they will be kept up to date at all times. For instance:

\begin{verbatim}
val frame = Frame(new Behaviour(time => sin(time)), 200) 
\end{verbatim}

      This would create a Frame that at a time `t' would have a width of \emph{sin(t)}.

      The implementation of this is based around re-evaluating and redrawing the graphics on a clock tick. Each 
      \emph{Frame} has its own `clock' that updates all the components attached to the frame at a standard interval (currently 
      20ms). The actual graphical code was built by simply abstracting over the Java Swing UI Framework. This allows the FRP 
      components to be built quickly as no actual lower end graphics code has to be implemented.

      The UI framework also allows the programmer to interact with the user via \emph{Events}. Again this is best illustrated 
      with an example:

\begin{verbatim}
val button = Button("Click Me!") 
val hello = new Behaviour(time => "Hello")
val goodbye = new Behaviour(time => "Goodbye!")
val someString = hello.until(button.click, goodbye) 
\end{verbatim}

      Here it can be seen that the \emph{Button} type owns a `click' event. This \emph{Event} occurs every time the 
      \emph{Button} is clicked by the user. This was made possible by abstracting over Swing's own event framework. Many other 
      FRP \emph{Events} can be easily generated in this way in Swing.
    
    \subsection{IO Framework}
    
    As mentioned earlier FRP can ease programming functional I/O as FRP \emph{Events} introduce a declarative way to represent 
    and interact with external sources. One obvious place to experiment with this is with socket programming. To create socket 
    in FRP the two core Java socket abstractions \emph{Socket} and \emph{ServerSocket} were abstracted over to produce
    \emph{Sender} and \emph{Receiver}. 

    \emph{Sender} represents an output socket and is constructed from an IP to connect to, a host port and an 
    \emph{EventSource[String]}. Any occurrences in the \emph{Event} will be sent to IP and port specified. The \emph{Receiver} 
    type only requires a port to be constructed but is itself an \emph{EventSource[String]} of received messages. This allows 
    a programmer to send and receive messages between FRP applications running on different nodes (or in different processes).
    Here's an example program that sends a "Ping" message every time a Button is pressed:

\begin{verbatim}
val button = Button("Ping")
val pinger = button.map((t, v) => "Ping")
val sender = Sender("localhost", 1997, pinger)
val receiver = Receiver(1997)
\end{verbatim}
    
    Additional functionality can be added by allowing Receiver to reply to received messages. This can be achieved by
    having an optional \emph{String => Behaviour[String]} constructor argument. For example, a Receiver that replies
    ``Pong'' to each incoming message would be created like so:
 
\begin{verbatim}
val rec = Receiver(1997) {
  in => "Pong"
}
\end{verbatim}    

    One interesting problem encountered while developing the \emph{Socket} abstraction was that of \emph{Exceptions}. 
    \emph{Sockets} can fail in many ways and in a JVM language this causes an exception which will cause the program to exit. 
    The simplest way to deal with the problem would of course be to simply catch the exceptions and ignore them (if they 
    occur) but this would mean any code written with FRP would be intolerant of external failure (disconnection to the 
    internet etc). An elegant solution was to abstract over \emph{Exceptions} with \emph{Events}. To do this the socket types 
    have an `errors' \emph{Event} that occurs every time an exception is thrown within their execution. For instance, in this 
    setup there is nothing for the program to connect to on port \emph{1997}:

\begin{verbatim}
val socket = Sender("localhost", 1997, Event(0, "Hello")) 
\end{verbatim}

    Here the Java socket code will fail as it will be refused a connection (causing an exception). After the above line 
    executes we can then say the following is true:

\begin{verbatim}
socket.errors.occs.length == 1 
\end{verbatim}

    This allows exceptions to interact with the FRP paradigm and allows programmers to build failure tolerant systems within 
    an FRP setting.
    
  \section{Uses of FRP}
  
    \subsection{Demo Applications}
    
    \subsection{Use in the Wild}
    
    \subsection{Possible Large Scale Use}
    
  \section{Limitations}
    
    \subsection{Need for Abstraction}
    
    \subsection{Learning Curve}
    
    \subsection{Where to Stop}
    
  \section{Conclusion}
  
\end{document}